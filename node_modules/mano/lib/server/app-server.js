'use strict';

var last             = require('es5-ext/array/#/last')
  , noop             = require('es5-ext/function/noop')
  , assign           = require('es5-ext/object/assign')
  , dbjsFile         = require('dbjs-file/server')
  , http             = require('http')
  , https            = require('https')
  , readFileSync     = require('fs').readFileSync
  , resolve          = require('path').resolve
  , stat             = require('fs2/stat')
  , connect          = require('connect')
  , connectProto     = require('connect/lib/proto')
  , cookies          = require('cookies')
  , compress         = require('compression')
  , qsParse          = require('querystring').parse
  , mano             = require('../../')
  , tryRequire       = require('../utils/try-require').bind(require)
  , appRequest       = require('./server/app')
  , clientId         = require('./server/client-id')
  , bodyParser       = require('./server/body-parser')
  , authentication   = require('mano-auth/server/authentication')
  , basePostRoutes   = require('mano/controller/server')
  , st               = require('./server/static')
  , post             = require('./server/post')
  , appRouter        = require('./server/app-router')
  , serverSentEvents = require('./server/server-sent-events')
  , webmake          = require('./server/webmake')
  , getCss           = require('./server/get-css')
  , getPostRouter    = require('../../server/post-router')
  , joinControllers  = require('../../utils/join-controllers')

  , create = Object.create, AppServer;

connectProto.use = (function (use) {
	var byOrder = function (a, b) { return a.order - b.order; };
	return function (route, fn, order) {
		var lastItem;
		use.apply(this, arguments);
		if (typeof route === 'function') order = fn;
		if (isNaN(order)) order = Infinity;
		lastItem = last.call(this.stack);
		lastItem.order = order;
		this.stack.sort(byOrder);
		return this;
	};
}(connectProto.use));

AppServer = module.exports = function (conf, db) {
	var app, port, ssl, server, root, uploadsDir;

	root = conf.root;
	this.app = app = connect();
	this.env = conf;
	this.db = db;

	// Parse URL
	app.use(function (req, res, next) {
		req.query = req._parsedUrl.query ? qsParse(req._parsedUrl.query) : {};
		req._mime = (req.headers['content-type'] || '').split(';')[0];
		next();
	}, 0);

	// Framework statics
	this.app.use(compress(), 0.5);
	this.app.use(st(resolve(__dirname, '../public'), this.env), 1);
	this.app.use(st(resolve(root, 'public'), this.env), 1);

	// Eventual uploads
	stat(uploadsDir = resolve(root, 'uploads')).done(function (stat) {
		if (!stat.isDirectory()) return;
		this.app.use(st(uploadsDir, this.env, { cache: { fd: false } }), 3);
	}.bind(this), noop);

	// Parse cookies
	app.use(cookies.connect(), 6);

	// Client ID
	app.use(clientId, 7);

	// Bundlers (in case of dev mode):
	if (this.env.dev) {
		// Generate client bundle on the fly
		this.app.use(webmake.bind(this.webmakeRoutes = create(null)), 8);
		this.app.use(getCss().bind(this.cssRoutes = create(null)), 8);
	}

	// Parse POST requests
	app.use(bodyParser({
		uploadDir: resolve(root, conf.tmpFolder || 'tmp'),
		limit: '100mb'
	}), 10);

	// Authenticate
	app.use(authentication.sessionMiddleware, 15);
	app.use(authentication.logoutMiddleware, 15);

	// App router
	app.use(appRouter.bind(this.appResolvers = []), 16);

	// POST requests
	if (db.File) basePostRoutes.upload = dbjsFile(db, uploadsDir);
	app.use(post.bind(this.postRoutes = {}), 17);

	// Handle Server -> Client update stream
	app.use(serverSentEvents, 20);

	// GET requests
	app.use(appRequest.bind(mano.appRoutes = this.appRoutes = {}), 21);

	// Configure & start server
	ssl = conf.ssl;
	port = Number(conf.port);
	if (isNaN(port)) port = ssl ? 443 : 80;

	if (ssl) {
		this.server = server = https.createServer({
			key: ssl.key && readFileSync(resolve(root, ssl.key)),
			cert: ssl.cert && readFileSync(resolve(root, ssl.cert)),
			pfx: ssl.pfx && readFileSync(resolve(root, ssl.pfx)),
			passphrase: ssl.passphrase
		}, app);
	} else {
		this.server = server = http.createServer(app);
	}
	server.on('error', function (err) {
		console.error("Server error!");
		throw err;
	});
	server.on('close', function () { throw new Error("Server closed!"); });
	mano.httpServer = server;
	server.listen(port);
};

assign(AppServer.prototype, {
	add: function (conf) {
		var root, name;

		root = conf.root;
		name = conf.name || 'main';

		this.appResolvers.push({
			name: name,
			check: conf.route,
			forceLegacy: conf.forceLegacy,
			forceLegacyFullRender: conf.forceLegacy || conf.forceLegacyFullRender
		});

		if (this.env.dev) {
			// Generate client bundle on the fly
			this.webmakeRoutes['/' + name + '.js'] = {
				path: resolve(root, 'client/program.js'),
				tplsPath: resolve(root, conf.viewPath || 'view')
			};
			this.webmakeRoutes['/' + name + '.legacy.js'] = {
				path: resolve(root, 'client/legacy.js')
			};

			this.cssRoutes['/' + name + '.css'] = resolve(root, 'client/css.index');
			this.cssRoutes['/' + name + '-legacy.css'] = this.cssRoutes['/' + name + '.css'];
			this.cssRoutes['/' + name + '-print.css'] = resolve(root, 'client/css-print.index');
		}

		// Statics and homepage
		this.app.use(st(resolve(root, 'public'), this.env), 9);

		// POST routes
		if (conf.useNewPostController) {
			this.postRoutes[name] = getPostRouter(joinControllers(
				require(resolve(root, 'controller')),
				tryRequire(resolve(root, 'controller/server'))
			), mano.legacyPool);
		}

		// Any application page
		this.appRoutes[name] = resolve(root, conf.viewPath || 'view');
		if (conf.middlewares) {
			conf.middlewares.forEach(function (data) {
				if (!data.global && isNaN(data.order)) data.order = 20.5;
				if (!data.global && (data.order < 16)) {
					throw new Error("App local middlewares must have order greater or equal 16 " +
						"(otherwise they're run before app name is resolved)");
				}
				this.app.use(data.global ? data.processor : function (req, res, next) {
					var appName = req.$appName;
					if (name !== appName) {
						next();
						return;
					}
					data.processor.call(mano, req, res, next);
				}, data.order);
			}, this);
		}
	}
});
