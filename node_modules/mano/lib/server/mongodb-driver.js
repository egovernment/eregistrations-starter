'use strict';

var copy     = require('es5-ext/object/copy')
  , deferred = require('deferred')
  , mongodb  = require('mongodb/lib/mongodb')

  , keys = Object.keys, promisify = deferred.promisify
  , Mongo = mongodb.Db, Server = mongodb.Server;

module.exports = function (config) {
	var mongo, collection, updateOpts, getAll, state = Object.create(null), init;

	mongo = new Mongo(config.name,
		new Server(config.host, config.port, {}), { w: 1 });
	mongo = promisify(mongo.open).call(mongo)(function (db) {
		return config.user ?
				promisify(db.authenticate).call(db, config.user, config.password)(db) :
				db;
	});

	collection = mongo.invokeAsync('collection', config.collection);

	getAll = function () {
		return collection.invokeAsync('find', {}, {})(function self(cursor) {
			return promisify(cursor.toArray).call(cursor);
		});
	};
	init = getAll()(function (obj) {
		obj.forEach(function (obj) { state[obj._id] = obj.stamp; });
	});

	updateOpts = { upsert: true, safe: true };
	return {
		collectionName: config.collection,
		getAll: function () { return getAll(); },
		update: function (id, data) {
			return collection.invokeAsync('update', { _id: id }, data, updateOpts)
				.aside(function () { state[id] = data.stamp; });
		},
		delete: function (id) {
			return collection.invokeAsync('remove', { _id: id })
				.aside(function () { delete state[id]; });
		},
		close: function () { return mongo.invoke('close'); },
		watchUpdates: function (cb) {
			setTimeout(function self() {
				var time = Date.now();
				init(getAll).done(function (obj) {
					var ids = copy(state), added = [], updated = [], deleted;
					obj.forEach(function (obj) {
						if (!state[obj._id]) added.push(obj);
						else if (state[obj._id] !== obj.stamp) updated.push(obj);
						else delete ids[obj._id];
					});
					deleted = keys(ids);
					if (added.length || updated.length || deleted.length) {
						cb({ added: added, updated: updated, deleted: deleted });
					}
					console.log("Search for updates in ",
						((Date.now() - time) / 1000).toFixed(2) + "s",
						added, updated, deleted);
					setTimeout(self, 5000);
				});
			}, 5000);
		}
	};
};
