'use strict';

var toArray        = require('es5-ext/array/to-array')
  , assign         = require('es5-ext/object/assign')
  , forEach        = require('es5-ext/object/for-each')
  , d              = require('d')
  , autoBind       = require('d/auto-bind')
  , lazy           = require('d/lazy')
  , debug          = require('debug-ext')('client')
  , deferred       = require('deferred')
  , ee             = require('event-emitter')
  , Fragment       = require('data-fragment/group')
  , resolve        = require('path').resolve
  , readFile       = require('fs2/read-file')
  , writeFile      = require('fs2/write-file')
  , timeUuid       = require('time-uuid')
  , once           = require('timers-ext/once')
  , generateHash   = require('murmurhash-js/murmurhash3_gc')
  , Sync           = require('../utils/sync')
  , getAppFragment = require('./get-app-fragment')
  , userAppMap     = require('./user-app-map')

  , create = Object.create, keys = Object.keys, hasOwnProperty = Object.prototype.hasOwnProperty
  , parse = JSON.parse, stringify = JSON.stringify
  , inProgress = Object.create(null)

  , Client, counter = 0;

Client = module.exports = function (ua, id, appId, clientDataMap) {
	this.ua = ua;
	this._id_ = id || timeUuid();
	this.clientDataMap = clientDataMap || create(null);
	Client[this._id_] = this;
	this.initPromise = this.init(appId)(this);
};

Client.get = function (req) {
	var promise, id = req.$clientId, ua = req.headers['user-agent'] || '';
	if (id == null) throw new TypeError("id is required");
	if (inProgress[id]) {
		return inProgress[id].aside(function (client) { client.adaptRequest(req); });
	}
	if (Client.hasOwnProperty(id)) {
		return Client[id].initPromise.aside(function (client) { client.adaptRequest(req); });
	}
	if (!Client.hasOwnProperty('dataPath')) throw new Error("Client data path not set");
	promise = readFile(resolve(Client.dataPath, id))(parse)(function (data) {
		return (new Client(ua, id, data.appId, data.appId && data.dataMap)).initPromise;
	}, function () {
		return (new Client(ua, id)).initPromise;
	}).aside(function (client) { client.adaptRequest(req); });
	return (inProgress[id] = promise);
};

Client.getAppFragment = getAppFragment;

ee(Object.defineProperties(Client.prototype, assign({
	init: d(function (appId) {
		debug.open("%s initialisation %s [%s]", this._id_, this.ua, ++counter);
		this.appId = appId;
		return deferred(this.dataFragment.promise).aside(function () {
			forEach(this.clientDataMap, function (updated, id) {
				if (!this.dataFragment.dataMap[id]) this.sync.remove(id);
			}, this);
			debug.close();
		}.bind(this));
	}),
	adaptRequest: d(function (req) {
		if (!req.$user) this.logout();
		else this.login(req.$user);
	}),
	isSync: d.gs(function () { return !this.sync._size; }),
	reinitialize: d(function () {
		this.clientDataMap = create(null);
		forEach(this.dataFragment.dataMap, function (event, id) { this.sync.update(id, event); }, this);
		this.save();
	}),
	stateHash: d.gs(function () { return String(generateHash(this.stateString)); }),
	stateString: d.gs(function () { return this.stateArray.join('|'); }),
	stateArray: d.gs(function () {
		var hash = [];
		forEach(this.clientDataMap, function (stamp, id) { hash.push(id + '.' + stamp); });
		return hash.sort();
	}),
	onConnect: d(function () {
		var hash;
		this.emit('connect', this.connection);
		if (!this.isSync) {
			debug("%s connected, not in sync!", this._id_);
			return;
		}
		hash = this.stateHash;
		this.connection.send('sync', hash);
	}),
	connection: d(null),
	login: d(function (userId) {
		if (this._userId === userId) return;
		if (this._userId) userAppMap.off(this._userId, this.setAppId);
		this._userId = userId;
		debug.open("%s login %s", this._id_, userId);
		userAppMap.get(userId).done(this.setAppId);
		userAppMap.on(userId, this.setAppId);
		debug.close();
	}),
	logout: d(function () {
		if (!this._userId) return;
		debug.open("%s logout", this._id_, this._userId);
		userAppMap.off(this._userId, this.setAppId);
		this._userId = null;
		this.appId = null;
		debug.close();
	}),
	_appId: d(null),
	appId: d.gs(function () { return this._appId; }, function (appId) {
		var old, nu;
		if (this._appId === appId) return;
		this._appId = appId;
		old = toArray(this.dataFragment._fragments)[0];
		if (appId) nu = Client.getAppFragment(appId);
		if (old === nu) return;
		if (nu) this.dataFragment.addFragment(nu);
		if (nu && nu.promise && !nu.promise.resolved) {
			this.appFragmentPromise = nu.promise;
			nu.promise.done(function () {
				if (this.appFragmentPromise === nu.promise) delete this.appFragmentPromise;
			}.bind(this));
			if (old) {
				nu.promise.done(function () {
					this.dataFragment.deleteFragment(old);
					this.dataFragment.flush();
				}.bind(this));
			}
		} else {
			if (old) this.dataFragment.deleteFragment(old);
			this.dataFragment.flush();
		}
	}),
	confirm: d(function (id, event) {
		if (event && (event.value !== '')) this.clientDataMap[id] = event.stamp;
		else delete this.clientDataMap[id];
		this.save();
	})
}, autoBind({
	setAppId: d(function (appId) { this.appId = appId; }),
	onUpdate: d(function (data) {
		forEach(data.updated, function (event, id) {
			if (!hasOwnProperty.call(this.sync._dirty, id)) {
				if (event.value === '') {
					if (!hasOwnProperty.call(this.clientDataMap, id)) return;
				} else {
					if (event.stamp === this.clientDataMap[id]) return;
				}
			}
			this.sync.update(id, event);
		}, this);
		keys(data.deleted).forEach(function (id) {
			if (!hasOwnProperty.call(this.sync._dirty, id) &&
					!hasOwnProperty.call(this.clientDataMap, id)) {
				return;
			}
			this.sync.remove(id);
		}, this);
	})
}), lazy({
	dataFragment: d(function () {
		var fragment = new Fragment();
		fragment.on('update', this.onUpdate);
		return fragment;
	}),
	save: d(function () {
		return once(function () {
			writeFile(resolve(Client.dataPath, this._id_), stringify({
				ua: this.ua,
				appId: this.appId,
				dataMap: this.clientDataMap
			})).done(null, function (e) { console.error("Could not write client file: " + e.stack); });
		}.bind(this));
	}),
	sync: d(function () {
		var sync = new Sync(this);
		sync.on('dirty', function (dirty, size) {
			if (!size) this.emit('sync');
		}.bind(this));
		return sync;
	}),
	sseWaiting: d(function () { return create(null); })
}))));
