'use strict';

var ee               = require('event-emitter')
  , EventSource      = require('event-source')
  , unserializeEvent = require('dbjs/_setup/unserialize/event')
  , unserializeValue = require('dbjs/_setup/unserialize/value')
  , Event            = require('dbjs/_setup/event')
  , server           = require('./xhr-driver')
  , lsPrefix         = require('./local-storage-driver').prefix
  , mano             = require('../../')
  , sessionId        = require('./session-id')

  , db = mano.db, unserializeObject = db.objects.unserialize
  , source, emittedHash, initialize;

var load = function (str) {
	var value, obj, data;
	if (str[0] === '-') {
		str = str.slice(1);
		db.objects.emit('delete', str);
		return;
	}
	data = unserializeEvent(str);
	if (!mano.noData) {
		value = unserializeValue(data.value, db.objects);
		obj = unserializeObject(data.id, value && value.constructor);
		if (obj != null) new Event(obj, value, data.stamp, 'server'); //jslint: ignore
	}
	if (localStorage[lsPrefix + data.id]) {
		if (Number(localStorage[lsPrefix + data.id].split('.', 1)[0]) >= data.stamp) return;
	}
	if (!data.value) delete localStorage[lsPrefix + data.id];
	else localStorage[lsPrefix + data.id] = data.stamp + '.' + data.value;
};

var emitSync = function (hash) {
	if (source && (source.readyState !== 1)) return;
	exports.isSync = true;
	emittedHash = hash;
	exports.emit('sync', hash);
	localStorage._sync = hash;
};

var onOpen = function () {
	console.log("Server connection: Open");
	exports.emit('open');
};
var onError = function () {
	console.error("Server connection: Error");
	exports.isSync = false;
	exports.emit('error');
};
var onMessage = function (event) {
	var data = event.data.split('\n'), action = data[0];
	data = data.slice(1);
	console.log("Server -> Client", '[' + action + ']', "length:", data.length,
		"id:", event.lastEventId);
	if (action === 'dbupdate') {
		exports.isSync = false;
		db._postponed_ += 1;
		data.forEach(load);
		db._postponed_ -= 1;
		server.post('/confirm-update/', { id: event.lastEventId })
			.done(function (hash) {
				if (hash === 'OK') return;
				emitSync(hash);
			});
		return;
	}
	if (action === 'sync') {
		emitSync(data[0]);
		return;
	}
	console.error("Unsupported action: \"" + action + "\"");
};

var checkMaster = function () {
	var savedSessionId, stamp, index;
	if (!localStorage._sseSessionId) {
		// No session saved we're obviously a master
		localStorage._sseSessionId = sessionId + '.' + Date.now();
		initialize();
		return;
	}
	index = localStorage._sseSessionId.indexOf('.');
	if (index === -1) {
		// Invalid value saved, assume we're master
		localStorage._sseSessionId = sessionId + '.' + Date.now();
		initialize();
		return;
	}
	savedSessionId = localStorage._sseSessionId.slice(0, index);
	stamp = Number(localStorage._sseSessionId.slice(index + 1));
	if (savedSessionId === sessionId) {
		// It's our session id that's saved, we're master
		localStorage._sseSessionId = sessionId + '.' + Date.now();
		initialize();
		return;
	}
	// if other master session is ongoing, we're slave
	if ((stamp + 2000) > Date.now()) {
		if (source && (source.readyState !== 2)) {
			console.log("Server connection: Closed (taken over by other tab)");
			source.close();
			exports.emit('close');
		}
		return;
	}
	// Otherwise we're master
	localStorage._sseSessionId = sessionId + '.' + Date.now();
	initialize();
};

initialize = function () {
	if (exports.closed) return;
	if (source && (source.readyState !== 2)) return;
	source = exports.source = new EventSource('/update-stream/?csid=' + sessionId);
	source.onopen = onOpen;
	source.onerror = onError;
	source.onmessage = onMessage;
};

ee(exports);

exports.isSync = false;
checkMaster();
setInterval(checkMaster, 1000);

if (window && window.browser && (typeof window.browser.on === 'function')) {
	window.browser.on('closed', function () {
		exports.closed = true;
		source.close();
		exports.emit('close');
	});
}

window.addEventListener('storage', function (e) {
	var key = e.key;

	if (!key) return;
	if (key !== '_sync') return;
	if (!e.newValue) return;
	if (e.newValue === emittedHash) return;
	emitSync(e.newValue);
});
