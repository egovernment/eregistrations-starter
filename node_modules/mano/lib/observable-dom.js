'use strict';

var aFrom           = require('es5-ext/array/from')
  , separate        = require('es5-ext/array/#/separate')
  , isObject        = require('es5-ext/object/is-object')
  , d               = require('d')
  , memoize         = require('memoizee/plain')
  , getNormalizer   = require('memoizee/normalizers/get-1')
  , remove          = require('dom-ext/node/#/remove')
  , normalize       = require('dom-ext/document/#/normalize')
  , isDF            = require('dom-ext/document-fragment/is-document-fragment')
  , observable      = require('observable-value').prototype
  , Multiple        = require('dbjs/_setup/2.multiple-item/multiple')
  , DynamicMultiple = require('dbjs/_setup/1.property/dynamic-multiple')
  , serialize       = require('dbjs/_setup/serialize/value')

  , isArray = Array.isArray, toDOM, toDOMAttr
  , normalizer = function (args) { return serialize(args[0]); };

Object.defineProperties(observable, {
	toDOM: d(function (document) {
		// TODO: Consider solution when two markers (markStart and markEnd) are used
		// to clarify range which we cover with this observable.
		// Then results at all times could be kept in DOM elements, and we shouldn't run into
		// issue when some interim changes to disconnected nodes cannot be properly propagated
		// as node doesn't have any surrounds (parent node).
		// e.g. see: https://github.com/egovernment/eregistrations-salvador/commit/
		//    e284a0ebc99cb60c69d28a81982a514fe5dafab7
		var mark = document.createTextNode(''), df, toDOM, current;

		toDOM = memoize(function (value) {
			return normalize.call(document, value);
		}, { normalizer: getNormalizer() });
		this.on('change', function (event) {
			var parent, value = event.newValue;
			if (current) {
				if (isArray(current)) {
					current.forEach(function (el) {
						if (el.parentNode === mark.parentNode) remove.call(el);
					});
				} else {
					if (current.parentNode === mark.parentNode) remove.call(current);
				}
				current = null;
			}
			if (!isObject(value)) {
				mark.data = (value == null) ? '' : String(value);
				return;
			}
			mark.data = '';
			current = toDOM(value);
			if (!current) return;
			parent = mark.parentNode;
			if (!parent) throw new TypeError("Cannot update DOM");

			if (isArray(current)) {
				current.forEach(function (el) { parent.insertBefore(el, mark); });
				return;
			}
			parent.insertBefore(current, mark);
		});
		if (!isObject(this.value)) {
			mark.data = (this.value == null) ? '' : String(this.value);
			return mark;
		}
		current = toDOM(this.value);
		if (!current) return mark;
		df = document.createDocumentFragment();
		if (isArray(current)) current.forEach(df.appendChild, df);
		else df.appendChild(current);
		df.appendChild(mark);
		return df;
	}),
	toDOMAttr: d(function (element, name) {
		this.on('change', function (event) {
			var value = event.newValue;
			if ((value == null) || (value === false)) element.removeAttribute(name);
			else if (value === true) element.setAttribute(name, name);
			else element.setAttribute(name, value);
		});
		if ((this.value == null) || (this.value === false)) element.removeAttribute(name);
		else if (this.value === true) element.setAttribute(name, name);
		else element.setAttribute(name, this.value);
		return this;
	})
});

Object.defineProperties(Multiple.prototype, {
	toDOM: d(toDOM = function (document) {
		var mark = document.createTextNode(''), df, toDOM, current, els
		  , type = this.object._getDescriptor_(this.__pSKey__ || this.__sKey__).type;

		toDOM = memoize(function (value) {
			var text = type.toDOMText(document), dom;
			text.value = value;
			dom = text.dom;
			if (!isDF(dom)) return dom;
			return dom.firstChild ? aFrom(dom.childNodes) : null;
		}, { normalizer: normalizer });
		this.on('change', function (event) {
			var parent, els;
			if (current) {
				if (isArray(current)) {
					current.forEach(function (el) { remove.call(el); });
				} else {
					remove.call(current);
				}
				current = null;
			}
			mark.data = '';
			if (!this.size) return;
			els = [];
			this.forEach(function (value) {
				value = toDOM(value);
				if (value != null) els.push(value);
			});
			if (!els.length) return;
			if (els.length === 1) current = els[0];
			else current = separate.call(els, document.createTextNode(", "));
			parent = mark.parentNode;
			if (!parent) throw new TypeError("Cannot update DOM");

			if (isArray(current)) {
				current.forEach(function (el) { parent.insertBefore(el, mark); });
				return;
			}
			parent.insertBefore(current, mark);
		});
		if (!this.size) return mark;
		els = [];
		this.forEach(function (value) {
			value = toDOM(value);
			if (value != null) els.push(value);
		});
		if (!els.length) return mark;
		if (els.length === 1) current = els[0];
		else current = separate.call(els, document.createTextNode(", "));
		df = document.createDocumentFragment();
		if (isArray(current)) current.forEach(df.appendChild, df);
		else df.appendChild(current);
		df.appendChild(mark);
		return df;
	}),
	toDOMAttr: d(toDOMAttr = function (element, name) {
		var update;
		this.on('change', update = function () {
			if (!this.size) element.removeAttribute(name);
			element.setAttribute(name, this.toString(" "));
		});
		update.call(this);
		return this;
	})
});

Object.defineProperties(DynamicMultiple.prototype, {
	toDOM: d(toDOM),
	toDOMAttr: d(toDOMAttr)
});
