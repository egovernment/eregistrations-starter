'use strict';

var forEach      = require('es5-ext/object/for-each')
  , ensureString = require('es5-ext/object/validate-stringifiable-value')
  , debug        = require('debug-ext')('db-data-sync')
  , Client       = require('../lib/server/client')
  , db           = require('../').db

  , create = Object.create, keys = Object.keys;

exports['confirm-update'] = {
	validate: function (data) { return ensureString(data.id); },
	submit: function (id) {
		return Client.get(this.req)(function (client) {
			var promise = client.sseWaiting[id];
			if (promise) promise.resolve();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports.dbupdate = {
	validate: function (data) { return ensureString(data.data); },
	submit: function (data) {
		return Client.get(this.req)(function (client) {
			var result;
			db._postponed_ += 1;
			data = data.trim().split('\n');
			debug("%s client -> server", client._id_);
			console.log(data);
			data = data.map(function (data) {
				var event, id;
				if (!data) return;
				event = db.unserializeEvent(data, client._id_);
				id = event.object.__valueId__;
				if (event.value === undefined) delete client.clientDataMap[id];
				else client.clientDataMap[id] = event.stamp;
				return event;
			});
			client.save();
			db._postponed_ -= 1;
			this.dbRelease();
			if (client.appFragmentPromise) {
				return client.appFragmentPromise(function () {
					var result = client.isSync ? client.stateHash : true;
					debug("%s server respond to /dbupdate/", client._id_, result);
					return result;
				});
			}
			result = client.isSync ? client.stateHash : true;
			debug("%s server respond to /dbupdate/", client._id_, result);
			return result;
		}.bind(this));
	}
};

exports['data-initialization'] = {
	validate: Function.prototype,
	submit: function (data) {
		return Client.get(this.req)(function (client) {
			client.reinitialize();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports['sync-confirm'] = {
	validate: function (data) { return ensureString(data.data); },
	submit: function (data) {
		return Client.get(this.req)(function (client) {
			var self = create(null), obsolete = [], missing = [], unsync = [], events = {}, result;

			// console.log("Client", client._id_, "confirm against\n" + client.stateArray.join('\n'));

			forEach(client.dataFragment.dataMap, function (event, id) {
				if (event.value === '') return;
				self[id] = event.stamp;
				events[id] = event;
			});

			data.split('\n').forEach(function (data) {
				var index = data.indexOf('.'), id, clientStamp, serverStamp;
				if (index === -1) throw new Error('Unrecognized sync data');
				id = data.slice(index + 1);
				if (self[id] == null) {
					obsolete.push(id);
					return;
				}
				clientStamp = Number(data.slice(0, index));
				serverStamp = self[id];
				delete self[id];
				if (serverStamp === clientStamp) return;
				if (Number(serverStamp) < Number(clientStamp)) unsync.push(id);
				else missing.push(id);
			});
			missing = missing.concat(keys(self));

			if (!obsolete.length && !missing.length && !unsync.length) {
				debug("%s sync confirm OK", client._id_);
				return true;
			}

			result = {};
			debug("%s sync confirm not OK", client._id_);
			if (obsolete.length) {
				console.log("Obsolete on Client", obsolete);
				result.obsolete = obsolete;
			}

			if (missing.length) {
				console.log("Missing on Client", missing);
				result.missing = missing;
				missing.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			if (unsync.length) {
				console.log("Not in sync on Client", unsync);
				result.unsync = unsync;
				unsync.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			return result;
		});
	}
};
