'use strict';

var aFrom             = require('es5-ext/array/from')
  , flatten           = require('es5-ext/array/#/flatten')
  , last              = require('es5-ext/array/#/last')
  , forEach           = require('es5-ext/object/for-each')
  , ensureString      = require('es5-ext/object/validate-stringifiable-value')
  , uncapitalize      = require('es5-ext/string/#/uncapitalize')
  , Set               = require('es6-set')
  , Map               = require('es6-map')
  , deferred          = require('deferred')
  , unserializeEvent  = require('dbjs/_setup/unserialize/event')
  , resolveKeyPath    = require('dbjs/_setup/utils/resolve-key-path')
  , debug             = require('debug-ext')('db-data-sync')
  , microtimeNow      = require('microtime-x')
  , Client            = require('../lib/server/client')
  , resolveUserAccess = require('../lib/server/resolve-user-access')
  , mano              = require('mano')
  , idToStorage       = require('eregistrations/server/utils/any-id-to-storage')

  , byStamp = function (a, b) { return a.stamp - b.stamp; }
  , isProtoId = RegExp.prototype.test.bind(/^7[A-Z][a-z0-9A-Z]+#$/)
  , dbDriver = mano.dbDriver, dbDriverGlobal = mano.dbDriverGlobal
  , create = Object.create, keys = Object.keys, stringify = JSON.stringify;

var resolveStorage = function (protoId) {
	var storageName = uncapitalize.call(protoId.slice(1, -1));
	return dbDriver.hasStorage(storageName)(function (result) {
		if (result) return dbDriver.getStorage(storageName);
		if (!dbDriverGlobal) return;
		return dbDriverGlobal.hasStorage(storageName)(function (result) {
			if (result) return dbDriverGlobal.getStorage(storageName);
		});
	})(function (storage) {
		if (!storage) throw new Error("No " + stringify(storageName) + " storage intialized on driver");
		return storage;
	});
};

exports['confirm-update'] = {
	validate: function (data) { return ensureString(data.id); },
	submit: function (id) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var promise = client.sseWaiting[id];
			debug("%s client -> server: confirmed db-update reception (%s)", clientWithSessionId, id);
			if (promise) promise.resolve();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports.dbupdate = {
	validate: function (data) { return ensureString(data.data); },
	submit: function (data) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var objIds = new Set(), initializedIds = create(null), records = new Map()
			  , events, timeDiff, lastStamp, tmpState = {};
			data = data.trim().split('\n');
			debug("%s client -> server", clientWithSessionId);
			console.log(data);
			events = flatten.call(data.map(function (data) {
				if (!data) return;
				return unserializeEvent(data, client._id_);
			})).sort(byStamp);
			lastStamp = events.length ?  last.call(events).stamp : 0;
			timeDiff = lastStamp - microtimeNow();
			if (timeDiff > 0) {
				debug("%s Events from future! %s", clientWithSessionId,
					(timeDiff / 1000000).toFixed(2) + "s");
				events.forEach(function (event) { event.stamp -= timeDiff; });
			} else {
				debug("%s event time diff %s", clientWithSessionId, (timeDiff / 1000000).toFixed(2) + "s");
			}
			return deferred.map(events, function (event) {
				var ownerId = event.id.split('/', 1)[0];
				if (event.value === '') {
					delete client.clientDataMap[event.id];
				} else {
					client.clientDataMap[event.id] = event.stamp;
					tmpState[event.id] = event.stamp;
				}
				if (ownerId === 'globalPrimitives') {
					// Special case, distribute per record id and not ownerId
					ownerId = 'globalPrimitives/' + resolveKeyPath(event.id);
				} else {
					objIds.add(ownerId);
					if (event.value[0] === '7') objIds.add(event.value.split('/', 1)[0].slice(1));
					if ((event.id === ownerId) && isProtoId(event.value)) {
						initializedIds[ownerId] = resolveStorage(event.value);
					}
				}
				return deferred(initializedIds[ownerId] || idToStorage(ownerId)(function (storage) {
					if (!storage) {
						console.error("\nUpdate for unknown object " + stringify(ownerId) + "\n");
						delete client.clientDataMap[event.id];
					}
					return storage;
				}))(function (storage) {
					if (!storage) return;
					if (initializedIds[ownerId]) idToStorage.setStorage(ownerId, storage);
					if (!records.has(storage)) records.set(storage, []);
					records.get(storage).push({
						id: event.id,
						data: { value: event.value, stamp: event.stamp }
					});
				});
			})(function () {
				return resolveUserAccess(objIds)(function () {
					return deferred.map(aFrom(records), function (data) {
						return data[0].storeMany(data[1]);
					})(function () {
						mano.slaveAccessFragment.flush();
						return deferred(mano.registerUserPromise)(function () {
							client.save();
							return deferred(client.appFragmentPromise)(function () {
								var result;
								forEach(tmpState, function (stamp, id) {
									if (client.clientDataMap[id] !== stamp) return;
									if (!client.dataFragment.dataMap[id]) {
										debug("%s unexpected record came from client (%s)", clientWithSessionId, id);
										client.sync.remove(id);
									}
								});
								result = client.isSync ? client.stateHash : true;
								debug("%s server respond to /dbupdate/ %s", clientWithSessionId, result);
								return result;
							});
						});
					});
				});
			});
		}.bind(this));
	}
};

exports['data-initialization'] = {
	validate: Function.prototype,
	submit: function (data) {
		return Client.get(this.req)(function (client) {
			client.reinitialize();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports['sync-confirm'] = {
	validate: function (data) { return ensureString(data.data); },
	submit: function (data) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var self = create(null), obsolete = [], missing = [], unsync = [], events = {}, result;

			// console.log("Client", client._id_, "confirm against\n" + client.stateArray.join('\n'));

			forEach(client.dataFragment.dataMap, function (event, id) {
				if (event.value === '') return;
				self[id] = event.stamp;
				events[id] = event;
			});

			data.split('\n').forEach(function (data) {
				var index = data.indexOf('.'), id, clientStamp, serverStamp;
				if (index === -1) throw new Error('Unrecognized sync data');
				id = data.slice(index + 1);
				if (self[id] == null) {
					obsolete.push(id);
					return;
				}
				clientStamp = Number(data.slice(0, index));
				serverStamp = self[id];
				delete self[id];
				if (serverStamp === clientStamp) return;
				if (Number(serverStamp) < Number(clientStamp)) unsync.push(id);
				else missing.push(id);
			});
			missing = missing.concat(keys(self));

			if (!obsolete.length && !missing.length && !unsync.length) {
				debug("%s sync confirm OK", clientWithSessionId);
				return true;
			}

			result = {};
			debug("%s sync confirm not OK", clientWithSessionId);
			if (obsolete.length) {
				console.log("Obsolete on Client", obsolete);
				result.obsolete = obsolete;
			}

			if (missing.length) {
				console.log("Missing on Client", missing);
				result.missing = missing;
				missing.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			if (unsync.length) {
				console.log("Not in sync on Client", unsync);
				result.unsync = unsync;
				unsync.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			return result;
		});
	}
};
