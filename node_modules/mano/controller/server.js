'use strict';

var aFrom             = require('es5-ext/array/from')
  , flatten           = require('es5-ext/array/#/flatten')
  , last              = require('es5-ext/array/#/last')
  , format            = require('es5-ext/date/#/format')
  , forEach           = require('es5-ext/object/for-each')
  , normalizeOptions  = require('es5-ext/object/normalize-options')
  , ensureString      = require('es5-ext/object/validate-stringifiable-value')
  , uncapitalize      = require('es5-ext/string/#/uncapitalize')
  , Set               = require('es6-set')
  , Map               = require('es6-map')
  , deferred          = require('deferred')
  , unserializeEvent  = require('dbjs/_setup/unserialize/event')
  , resolveKeyPath    = require('dbjs/_setup/utils/resolve-key-path')
  , mano              = require('mano')
  , isOwnerId         = require('eregistrations/utils/is-object-id')
  , idToStorage       = require('eregistrations/server/utils/any-id-to-storage')
  , fs                = require('fs2')
  , path              = require('path')
  , debug             = require('debug-ext')('db-data-sync')
  , microtimeNow      = require('microtime-x')
  , Client            = require('../lib/server/client')
  , userAppAccessMap  = require('../lib/server/user-app-access-map')
  , resolveUserAccess = require('../lib/server/resolve-user-access')
  , clientErrorFilter = require('./utils/client-error-logger-filter')

  , byStamp = function (a, b) { return a.stamp - b.stamp; }
  , isProtoId = RegExp.prototype.test.bind(/^7[A-Z][a-z0-9A-Z]+#$/)
  , isModelId = RegExp.prototype.test.bind(/^[A-Z]/)
  , dbDriver = mano.dbDriver, dbDriverGlobal = mano.dbDriverGlobal
  , create = Object.create, keys = Object.keys, stringify = JSON.stringify;

var resolveStorage = function (protoId) {
	var storageName = uncapitalize.call(protoId.slice(1, -1));
	return dbDriver.hasStorage(storageName)(function (result) {
		if (result) return dbDriver.getStorage(storageName);
		if (!dbDriverGlobal) return;
		return dbDriverGlobal.hasStorage(storageName)(function (result) {
			if (result) return dbDriverGlobal.getStorage(storageName);
		});
	})(function (storage) {
		if (!storage) throw new Error("No " + stringify(storageName) + " storage intialized on driver");
		return storage;
	});
};

exports['confirm-update'] = {
	validate: function (data) { return ensureString(data.id); },
	submit: function (id) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var promise = client.sseWaiting[id];
			debug("%s client -> server: confirmed db-update reception (%s)", clientWithSessionId, id);
			if (promise) promise.resolve();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports.dbupdate = {
	validate: function (data) { return ensureString(data.data); },
	submit: function (data) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var objIds = new Set(), initializedIds = create(null), records = new Map()
			  , events, timeDiff, lastStamp, tmpState = {};
			data = data.trim().split('\n');
			debug("%s client -> server", clientWithSessionId);
			console.log(data);
			events = flatten.call(data.map(function (data) {
				if (!data) return;
				return unserializeEvent(data, client._id_);
			})).sort(byStamp);
			lastStamp = events.length ?  last.call(events).stamp : 0;
			timeDiff = lastStamp - microtimeNow();
			if (timeDiff > 0) {
				debug("%s Events from future! %s", clientWithSessionId,
					(timeDiff / 1000000).toFixed(2) + "s");
				events.forEach(function (event) { event.stamp -= timeDiff; });
			} else {
				debug("%s event time diff %s", clientWithSessionId, (timeDiff / 1000000).toFixed(2) + "s");
			}
			return deferred.map(events, function (event) {
				var ownerId = event.id.split('/', 1)[0], valueOwnerId;
				if (event.value === '') {
					delete client.clientDataMap[event.id];
				} else {
					client.clientDataMap[event.id] = event.stamp;
					tmpState[event.id] = event.stamp;
				}
				if (ownerId === 'globalPrimitives') {
					// Special case, distribute per record id and not ownerId
					ownerId = 'globalPrimitives/' + resolveKeyPath(event.id);
				} else if (isOwnerId(ownerId)) {
					objIds.add(ownerId);
					if (event.value[0] === '7') {
						valueOwnerId = event.value.split('/', 1)[0].slice(1);
						if (isOwnerId(valueOwnerId)) objIds.add(valueOwnerId);
					}
					if ((event.id === ownerId) && isProtoId(event.value)) {
						initializedIds[ownerId] = resolveStorage(event.value);
					}
				} else if (isModelId(ownerId)) {
					// Note: This case should naturally be handled below with `idToStorage`, but
					// due to this flaw: https://github.com/medikoo/dbjs-persistence/blob/
					// df1dc68f81eddf224d0f8a9c941654a9926e9bbe/storage.js#L101
					// it isn't
					console.error("\nUpdate for unknown object " + stringify(ownerId) + "\n");
					delete client.clientDataMap[event.id];
					return;
				}
				return deferred(initializedIds[ownerId] || idToStorage(ownerId)(function (storage) {
					if (!storage) {
						console.error("\nUpdate for unknown object " + stringify(ownerId) + "\n");
						delete client.clientDataMap[event.id];
					}
					return storage;
				}))(function (storage) {
					if (!storage) return;
					if (initializedIds[ownerId]) idToStorage.setStorage(ownerId, storage);
					if (!records.has(storage)) records.set(storage, []);
					records.get(storage).push({
						id: event.id,
						data: { value: event.value, stamp: event.stamp }
					});
				});
			})(function () {
				return resolveUserAccess(objIds)(function () {
					return deferred.map(aFrom(records), function (data) {
						return data[0].storeMany(data[1]);
					})(function () {
						mano.slaveAccessFragment.flush();
						return deferred(mano.registerUserPromise)(function () {
							client.save();
							return deferred(client.appFragmentPromise)(function () {
								var result;
								forEach(tmpState, function (stamp, id) {
									if (client.clientDataMap[id] !== stamp) return;
									if (!client.dataFragment.dataMap[id]) {
										debug("%s unexpected record came from client (%s)", clientWithSessionId, id);
										client.sync.remove(id);
									}
								});
								result = client.isSync ? client.stateHash : true;
								debug("%s server respond to /dbupdate/ %s", clientWithSessionId, result);
								return result;
							});
						});
					});
				});
			});
		}.bind(this));
	}
};

exports['data-initialization'] = {
	validate: Function.prototype,
	submit: function (data) {
		return Client.get(this.req)(function (client) {
			client.reinitialize();
			return client.isSync ? client.stateHash : true;
		});
	}
};

exports['sync-confirm'] = {
	validate: function (data) { return ensureString(data.data).trim(); },
	submit: function (data) {
		var clientWithSessionId = this.req.$clientWithSessionId;
		return Client.get(this.req)(function (client) {
			var self = create(null), obsolete = [], missing = [], unsync = [], events = {}, result;

			// console.log("Client", client._id_, "confirm against\n" + client.stateArray.join('\n'));

			forEach(client.dataFragment.dataMap, function (event, id) {
				if (event.value === '') return;
				self[id] = event.stamp;
				events[id] = event;
			});

			if (data) {
				data.split('\n').forEach(function (recordData) {
					var index = recordData.indexOf('.'), id, clientStamp, serverStamp;
					if (index === -1) {
						console.log("Record", recordData);
						console.log("Data", data);
						throw new Error('Unrecognized sync data');
					}
					id = recordData.slice(index + 1);
					if (self[id] == null) {
						obsolete.push(id);
						return;
					}
					clientStamp = Number(recordData.slice(0, index));
					serverStamp = self[id];
					delete self[id];
					if (serverStamp === clientStamp) return;
					if (Number(serverStamp) < Number(clientStamp)) unsync.push(id);
					else missing.push(id);
				});
			}
			missing = missing.concat(keys(self));

			if (!obsolete.length && !missing.length && !unsync.length) {
				debug("%s sync confirm OK", clientWithSessionId);
				return true;
			}

			result = {};
			debug("%s sync confirm not OK", clientWithSessionId);
			if (obsolete.length) {
				console.log("Obsolete on Client", obsolete);
				result.obsolete = obsolete;
			}

			if (missing.length) {
				console.log("Missing on Client", missing);
				result.missing = missing;
				missing.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			if (unsync.length) {
				console.log("Not in sync on Client", unsync);
				result.unsync = unsync;
				unsync.forEach(function (id) { this.update(id, events[id]); }, client.sync);
			}

			return result;
		});
	}
};

var errorProps = ['location', 'buildStamp', 'message', 'source', 'line', 'column', 'errorMessage',
	'errorStack'];

exports['log-client-error'] = {
	validate: function (data) {
		var normalizedData = {}, parsedData;
		parsedData = JSON.parse(data.data);
		errorProps.forEach(function (key) { normalizedData[key] = parsedData[key]; });

		return normalizedData;
	},
	submit: function (normalizedData) {
		var now = new Date(), content = [], logFileName, messages, data, userId = this.req.$user
		  , appAccessId;

		if (userId) {
			userAppAccessMap.get(userId).done(function (accessId) { appAccessId = accessId; });
		}

		data = normalizeOptions({
			clientWithSessionId: this.req.$clientWithSessionId,
			agent: this.req.headers['user-agent'],
			utcDateTime: now.toISOString(),
			serverDateTime: format.call(now, '%Y-%m-%d %H:%M:%S'),
			referer: this.req.headers.referer,
			userId: userId,
			appName: this.req.$appName,
			appAccessId: appAccessId,
			ip: this.req.headers['x-real-ip']
		}, normalizedData);
		if (!clientErrorFilter.call(this, data)) return;

		messages = {
			clientWithSessionId: "Client & Session Id",
			agent: "User Agent",
			utcDateTime: "UTC Time",
			serverDateTime: "Server Time",
			referer: "Referer",
			ip: "IP",
			userId: "User Id",
			appName: "Application Name",
			appAccessId: "Application Access Id",
			location: "Location",
			buildStamp: "Build Stamp",
			message: "Message",
			source: "Source",
			line: "Line",
			column: "Column",
			errorMessage: "Error Message",
			errorStack: "Error Stack"
		};

		Object.keys(data).forEach(function (key) {
			content.push(messages[key] + ':\n------------------------------------', data[key] + '\n\n');
		});
		content = content.join('\n');
		logFileName = (now.toISOString() + '-' + data.clientWithSessionId).replace(/:/g, '_');

		// Meant to be used only in context of a child of some process manager
		if (process.send) {
			data.log = content;
			process.send({
				type: 'client-error-msg',
				data: data
			});
		}
		fs.writeFile(path.resolve(mano.env.root, 'log/client-errors/' + logFileName),
			content, { intermediate: true }).done();
	}
};
