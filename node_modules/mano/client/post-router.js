// Client-side router for POST requests (form submissions)

'use strict';

var startsWith           = require('es5-ext/string/#/starts-with')
  , deferred             = require('deferred')
  , dispatchEvent        = require('dom-ext/html-element/#/dispatch-event-2')
  , getFormData          = require('html-dom-ext/form/#/get-data')
  , interceptSubmit      = require('html-dom-event-ext/intercept-submit')
  , parse                = require('url3/parse')
  , resolve              = require('url3/resolve')
  , PostControllerRouter = require('post-controller-router')
  , db                   = require('mano').db
  , formStatus           = require('../lib/client/utils/form-status')
  , manoLocation         = require('../lib/client/location')
  , validate             = require('../utils/validate')
  , save                 = require('../utils/save')
  , remoteSubmit         = require('./utils/remote-submit')

  , stringify = JSON.stringify
  , inProgress, isDbReleased;

var dbRelease = function () {
	if (isDbReleased) return;
	isDbReleased = true;
	db._postponed_ -= 1;
};

module.exports = exports = function (routes, user) {
	var router = new PostControllerRouter(routes, {
		validate: validate,
		submit: save,
		remoteSubmit: remoteSubmit
	});
	interceptSubmit(document, location, function (form) {
		var action = parse(resolve(location.href, form.action), true), result, context;
		if (inProgress) {
			console.error("Form submission blocked due to previous one still ongoing");
			return;
		}
		isDbReleased = false;
		db._postponed_ += 1;
		try {
			var businessProcess = null;
			if (user && ['user', 'manager'].some(function (role) {
					return role === user.currentRoleResolved;
				})) {
				businessProcess = user.currentBusinessProcess;
			}
			result = router.routeEvent(context = {
				form: form,
				action: action,
				manager: (user && user.currentRoleResolved === 'manager') ? user : null,
				user: (user && (user.currentRoleResolved === 'manager')
					&& user.currentlyManagedUser) || user,
				businessProcess: businessProcess,
				dbRelease: dbRelease
			}, action.pathname, getFormData.call(form));
		} catch (e) {
			if (!isDbReleased) db._postponed_ -= 1;
			formStatus.showError.call(form, e);
			return;
		}
		if (!isDbReleased) db._postponed_ -= 1;
		if (!result) {
			throw new Error("POST route for " + stringify(action.pathname) + " not found");
		}
		inProgress = true;
		deferred(result.result).done(function (data) {
			var url = result.conf.redirectUrl, parsedUrl;
			inProgress = false;
			form.reset();
			dispatchEvent.call(form, 'reset');

			if (typeof url === 'function') url = url.call(context);
			if (url) {
				parsedUrl = parse(url);
				if ((parsedUrl.protocol && (parsedUrl.protocol != manoLocation.protocol)) ||
						(parsedUrl.host && (parsedUrl.host != manoLocation.host)) ||
						(parsedUrl.port && ((parsedUrl.port || 80) !== (manoLocation.port || 80))) ||
						(parsedUrl.auth != manoLocation.auth)) {
					location.href = url;
				} else {
					manoLocation.goto(url);
				}
				return;
			}
			if (!data) return;
			if (data === true) return;
			if (data === 'OK') return;
			if (data.message) {
				formStatus.showSuccess.call(form, data.message);
				return;
			}
			console.log("Controller result", data);
			console.error("Unsupported controller return");
			if (data && startsWith.call(data, '<!DOCTYPE')) {
				console.error("Most likely you forgot to specify return result in server controller.\n" +
					"If specified result is 'undefined' then server by default returns HTML of index " +
					"page, and that is unsupported result for XHR intiated requests.\n" +
					"If you do not wish to return anything specific, configure controller to return " +
					"'true', it'll be translated to \"OK\" message, that has no side effects");
			}
		}, function (e) {
			inProgress = false;
			formStatus.showError.call(form, e);
		});
	}, { method: 'POST' });
};
exports.validate = validate;
exports.submit = save;
exports.remoteSubmit = remoteSubmit;
