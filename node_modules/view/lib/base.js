'use strict';

var forEach          = Array.prototype.forEach
  , slice            = Array.prototype.slice
  , create           = Object.create
  , defineProperty   = Object.defineProperty
  , defineProperties = Object.defineProperties
  , isFunction       = require('es5-ext/function/is-function')
  , flatten          = require('es5-ext/array/#/flatten')
  , copy             = require('es5-ext/object/copy')
  , oForEach         = require('es5-ext/object/for-each')
  , isPlainObject    = require('es5-ext/object/is-plain-object')
  , toArray          = require('es5-ext/object/to-array')
  , d                = require('d')
  , ee               = require('event-emitter')
  , isDF             = require('dom-ext/document-fragment/is-document-fragment')
  , isNode           = require('dom-ext/node/is-node')
  , tree             = require('tree')

  , now = Date.now
  , findPath = tree.findPath

  , node, document, imp, resolveTpl, resetForms, ptrim
  , nodesToDf
  , sDocument, sCreateNode, sImp, sCreateDocument;

ptrim = (function () {
	var re = /[\u0000-\.0-\[\]-\uffff][\/\\]$/;
	return function (path) {
		return path.match(re) ? path.slice(0, -1) : path;
	};
}());

nodesToDf = function (el) {
	var df = el.ownerDocument.createDocumentFragment();
	while (el.firstChild) df.appendChild(el.firstChild);
	return df;
};

resolveTpl = function (tpl, engine, scope, parentScope) {
	var el, df;
	if (isDF(tpl)) return tpl;
	if (isNode(tpl)) {
		df = engine.document.createDocumentFragment();
		df.appendChild(tpl);
		return df;
	}
	if (typeof tpl === 'string') {
		el = engine.document.createElement('div');
		el.innerHTML = tpl;
		return nodesToDf(el);
	}
	if (isFunction(tpl)) return engine.collect(tpl.bind(scope, parentScope));
	throw new Error('Template type not supported');
};

node = create(tree.node(), {
	map: d('', null),
	resolved: d('', false),
	diff: d('e', function (data) {
		return this.appendChild(this.ownerDocument.createNode(arguments));
	}),
	load: d('e', function () {
		this.ownerDocument.load(this);
	}),
	destroy: d('e', function () {
		this.ownerDocument.destroy(this);
	}),
	setDynamic: d('', function (re, resolver, map) {
		var dynamic = [];
		this.dynamic.push(dynamic);
		dynamic.re = re;
		dynamic.resolver = resolver;
		dynamic.map = map;
		return dynamic;
	}),
	tryDynamic: d('', function (name, dynamic) {
		var match, scope, view;
		if (!(match = name.match(dynamic.re))) {
			return null;
		}
		scope = dynamic.resolver.apply(this, slice.call(match, 1));
		if (!scope) {
			return null;
		}
		view = this[name] =
			this.appendChild(this.ownerDocument.createNode(dynamic.map));
		dynamic.forEach(function (args) {
			view.diff.apply(view, args).scope = scope;
		}, this);
		view.scope = scope;
		return view;
	}),
	resolve: d('e', function (path) {
		var view = this;
		if (path[0] === '/') {
			view = this.ownerDocument.documentElement;
			if (view['/']) {
				view = view['/'];
			}
			path = path.slice(1);
		}
		ptrim(path).split('/').filter(Boolean).every(function (name) {
			var tview;
			if (name === '..') return (view = view.parentNode);
			if (name !== '.') {
				if (view[name]) return (view = view[name]);
				if (view.dynamic.some(function (item) {
						return (tview = this.tryDynamic(name, item));
					}, view)) {
					return (view = tview);
				}
				return (view = null);
			}
			return true;
		}, this);
		return view || null;
	}),
	resolveMap: d('', function () {
		var i, l, map, rmap, el, tl, tpl, item, engine, resolve, time, id;
		if (!this.resolved) {
			time = Date.now();
			map = this.map;
			i = 0;
			l = map.length;
			rmap = [];
			engine = this.ownerDocument.engine;
			if (l === 1) {
				map = flatten.call(toArray(this.ownerDocument.require(map[0])));
				l = map.length;
			}
			resolve = function (value, name) {
				if (!name) {
					item.to[''] = resolveTpl.call(this.ownerDocument, value, engine,
						this.scope, this.parentNode && this.parentNode.scope);
					return;
				}
				if (typeof value === 'string') {
					item.from[name] =
						el.hasAttribute(name) ? el.getAttribute(name) : null;
					return;
				}
				if (name !== 'class') throw new Error('Template type not supported');
				tl = item.from.class = {};
				oForEach(value, function (value, name) {
					tl[name] = el.classList.contains(name);
				});
			};
			do {
				if (map[i] === '_scroll') {
					defineProperty(this, 'scroll', d(map[++i]));
					++i;
					continue;
				}

				rmap.push(item = {});
				el = item.el = map[i++];
				if (typeof item.el !== "object") {
					id = item.el;
					el = item.el = engine.getById(id);
					if (!el) throw new TypeError("Cannot find element with '" + id + "' id");
				}
				tpl = map[i++];
				if (isPlainObject(tpl)) {
					item.to = copy(tpl);
					item.from = {};
					oForEach(tpl, resolve, this);
				} else {
					item.to = resolveTpl.call(this.ownerDocument, tpl, engine, this.scope,
						this.parentNode && this.parentNode.scope);
				}
			} while (i < l);
			defineProperties(this, {
				map: d('', rmap),
				resolved: d('', true)
			});
			console.log("View generation in",
				((now() - time) / 1000).toFixed(3) + "s");
		}
		return this;
	})
});

resetForms = function (el) {
	forEach.call(el.childNodes, function (el) {
		if (el.nodeName.toLowerCase() === 'form') {
			if (el.getAttribute('data-view-switch-reset') !== 'no') el.reset();
		} else if (el.querySelectorAll) {
			forEach.call(el.querySelectorAll('form'), function (form) {
				if (form.getAttribute('data-view-switch-reset') !== 'no') form.reset();
			});
		}
	});
};

sDocument = tree.document(node);
sCreateNode = sDocument.createNode;
document = ee(create(sDocument, {
	current: d('e', null),
	createNode: d('e', function (map) {
		return defineProperties(sCreateNode.call(this), {
			map: d('c', map),
			dynamic: d('', [])
		});
	}),
	load: d('e', function (view) {
		var path = findPath(this.current, view);
		if (path.length) {
			path.forEach(function (sub) {
				if (!sub.scope) sub.scope = view.scope;
				this.switch(sub);
			}, this);
			this.emit('load', view);
		}
	}),
	destroy: d('e', function (view) {
		var current;
		if ((current = (this.current === view))) {
			this.load(view.parentNode);
		}
		view.parentNode.removeChild(view);
		this.emit('destroy', view, current);
	}),
	switch: d('', function (to) {
		var dir = (to.parentNode === this.current), val;
		(dir ? to.resolveMap() : this.current).map.forEach(function (map) {
			val = map[dir ? 'to' : 'from'];
			if (isDF(val)) {
				map[dir ? 'from' : 'to'] = nodesToDf(map.el);
				map.el.appendChild(val);
				resetForms(map.el);
			} else {
				oForEach(val, function (value, name) {
					if (!name) {
						map[dir ? 'from' : 'to'][''] = nodesToDf(map.el);
						map.el.appendChild(value);
						resetForms(map.el);
					} else if (typeof value === 'string') {
						map.el.setAttribute(name, value);
					} else if (value === null) {
						map.el.removeAttribute(name);
					} else if (name === 'class') {
						oForEach(value, function (value, name) {
							map.el.classList[value ? 'add' : 'remove'](name);
						});
					} else {
						console.log(name, value);
						throw new Error('Unrecognized tpl setting');
					}
				});
			}
		});
		defineProperty(this, 'current', d('ce', to));
	})
}), true);

sImp = tree.implementation(document);
sCreateDocument = sImp.createDocument;
imp = create(sImp, {
	createDocument: d('e', function (engine, container, content, require) {
		if (typeof container === 'string') {
			container = engine.getById(container);
		}
		var doc = sCreateDocument.call(this,
			[container, content || container.childNodes]);
		defineProperties(doc, {
			current: d('ce', content ? doc : doc.documentElement),
			engine: d('e', engine),
			document: d('e', container.ownerDocument)
		});
		doc.require = require;
		doc.documentElement.load();
		return doc;
	})
});

module.exports = function (engine, container, content, require) {
	engine.getById = engine.document.getElementById.bind(engine.document);
	return imp.createDocument(engine, container, content, require);
};
