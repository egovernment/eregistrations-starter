'use strict';

var $           = require('./main')
  , isObject    = require('es3-ext/object/is-object')
  , forEach     = require('./for-each')
  , forIn       = require('./for-in')
  , create      = require('./create')
  , formData    = require('./form-data')
  , bindNesteds = require('./dbjs-bind-nesteds')
  , resolveSets = require('./dbjs-resolve-sets');

var resolveObjects = function (master, map) {
	forIn(map, function (map, name) {
		var index = name.indexOf('/'), nestedName, obj = master;
		while (index !== -1) {
			nestedName = name.slice(0, index);
			obj = obj[nestedName];
			if (!obj) return;

			name = name.slice(index + 1);
			index = name.indexOf('/');
		}
		if (obj[name] == null) return;
		if (typeof obj[name] === 'string') {
			obj[name] = map[obj[name]];
			return;
		}
		forEach(obj[name], function (id, index) { this[index] = map[id]; }, obj[name]);
	});
	return master;
};

module.exports = $.dbjsFormFill = function (obj, form, objMap) {
	var data, objData, prefix, i, name, re, match, nIndex, nestedName
	  , currentData, originData;
	objData = { master: obj };
	re = /^([a-zA-Z][a-zA-Z0-9]*)(?:\[(\d+)\])?$/;
	if (obj == null) throw new TypeError(obj + " is not an object");
	data = formData(form);
	prefix = obj.__id__ + '/';
	for (i in data) {
		if (!data.hasOwnProperty(i)) continue;
		if (i.indexOf(prefix) !== 0) continue;
		name = i.slice(prefix.length);
		currentData = objData;
		originData = obj;
		while ((nIndex = name.indexOf('/')) !== -1) {
			nestedName = name.slice(0, nIndex);
			name = name.slice(nIndex + 1);
			if (!currentData.hasOwnProperty(nestedName) || (currentData[nestedName] == null)) {
				if (originData && (nestedName in originData)) {
					if (!originData.hasOwnProperty(nestedName) || (originData[nestedName] == null)) {
						originData[nestedName] = create(originData[nestedName]);
					}
					currentData[nestedName] = originData[nestedName];
				} else {
					currentData[nestedName] = {};
				}
			}
			if (!isObject(currentData[nestedName])) currentData[nestedName] = [currentData[nestedName]];
			currentData = currentData[nestedName];
			if (originData) originData = originData[nestedName];
		}
		match = name.match(re);
		if (!match) continue;
		if (match[2]) {
			name = match[1];
			if (!currentData.hasOwnProperty(name)) currentData[name] = [];
			if (data[i] == null) continue;
			currentData[name][match[2]] = data[i];
		} else {
			currentData[name] = data[i];
		}
	}
	for (name in objData) {
		if (!objData.hasOwnProperty(name)) continue;
		obj[name] = objData[name];
	}
	bindNesteds(obj);
	if (objMap) resolveObjects(obj, objMap);
	return resolveSets(obj);
};
